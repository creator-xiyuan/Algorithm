# 第一章——引论
（1）递归的基本法则：有基准情形、可以朝着基准不断推进、假设所有的递归调用都能运行、在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性工作

# 第二章——算法分析
（1）算法是为求解一个问题所需要遵循的、被清楚地指定的简单指令的集合

# 第三章——表、栈和队列
（1）**模块化**有几个优点。首先，**调试小程序要容易得多**。第二，**多个人**同时对一个模块式程序编程要更容易。第三，一个写得好的模块化程序把某些依赖关系只局限在一个例程中，这样使得**修改起来会更容易**。全局变量和副作用是有害的观念也正是出于模块化是有益的想法。

### 3.2 表ADT
#### 1.表的简单数组实现
插入和删除的运行时间非常慢且表的大小必须已知，所以表一般不用简单数组来实现

#### 2.链表
**虚拟头节点**可以很有效的处理特殊情况

#### 3.程序设计细节
`见代码实现`

#### 4.常见的错误
- 指针未初始化就使用
- 没有检查指针P是否为NULL就使用P->Next
- 声明一个指向结构的指针并不创建该结构，不需要malloc

#### 5.双链表

#### 6.循环链表
有表头/无表头、单链表/双链表

#### 7.例子
##### 多项式ADT
`见代码实现`
==乘法部分未完成==

##### 基数排序
==未完成==

##### 多重表
==未完成==

#### 8.链表的游标实现
==未完成==


### 3.3 栈ADT
#### 2.栈的实现
由于栈是一个表，因此任何实现表的方法都能实现栈。
但是，如果使用好的编程原则，那么调用例程不必知道使用的是哪种方法

##### 栈的链表实现
`见代码实现`
链表实现的缺点在于**对malloc和free的调用的开销**是昂贵的
有的缺点可以通过第二个栈来避免，第二个栈初始时为空栈，当一个单元从第一个栈弹出时，它只是被放到了第二个栈中。此后，当第一个栈需要新的单元时，它首先去查找第二个栈

##### 栈的数组实现
`见代码实现`
这是一个**更流行**的解决方案，只是唯一潜在的危害是需要提**提前声明数组的大小**
在典型的应用程序中，**声明一个数组足够大而不至于浪费太多空间通常并没有什么困难**
如果做不到这一点，那么更好的做法是用链表来实现
最现代化的计算机将**栈操作**作为它的**指令系统的一部分**，使其能**更快的运行**，这个事实说明，**栈**可能是仅次于**数组**的**最基本**的数据结构
**一个影响栈的执行效率的问题是错误检查**。频繁的错误检查可能会增加代码的复杂性和执行的开销。特别是在大量的栈操作中，错误检查可能会成为**性能瓶颈**。因此，在设计和实现栈时，需要权衡错误检查的**必要性和开销**，根据具体的使用场景进行合理的优化。

#### 3.应用
##### 符号配对

##### 后缀表达式
`见代码实现`
1. 后缀表达式的计算
数字入栈，遇到符号弹出两个数字进行计算，将结果入栈
2. 中缀到后缀的转换


##### 函数调用
```C
void PrintList(List L)
{
    if(L)
    {
        PrintElement(L->Element);
        //尾递归
        PrintList(L->Next);
    }
}
```
**尾递归**（在最后一行的递归调用）是使用递归**极端不当**的例子，应当使用更加自然的while循环结构
递归总能被彻底除去（编译器是在转变成汇编语言时完成的），但这么做是相当冗长乏味的。
虽然非递归程序一般比等价的递归程序要快，但是清晰性不足

### 3.4 队列

#### 2.数组实现
`见代码实现`

#### 3.队列的应用
队列是一种**先进先出**的结构，在生活中随处可见



# 第四章——树
对于**大量的**输入数据，链表的**线性访问时间太慢**，不宜使用。
**树**的大部分操作的运行时间平均为**O(log N)**
### 4.1 预备知识
- 树的递归定义：一颗树是一些结点的集合。这个集合可以是空集；若非空，则一棵树由根节点r以及0个或N个非空子树组成，每一颗子树的根都被来自根r的一条有向的边(edge)所连接
- 一棵树中从根到每个节点恰好存在一条路径

#### 1.树的实现
由于每个节点的**儿子数可以变化很大且事先不可知**，因此在数据结构中建立到各儿子节点的**直接链接是不可行的**，因为这样会**浪费太多空间**
实际上解法很简单：将每个节点的所有儿子都放在树节点的链表中
```C
typedef struct TreeNode *ProToNode;

struct TreeNode
{
    ElementType Element;
    ProToNode FirstChild;
    ProToNode NextSibling;
}
```

#### 2.树的遍历及应用
树有很多应用。流行的用法之一是Unix等操作系统中的目录结构（严格来说是类树）
- 先序遍历——列出目录中的所有文件
```C
static void ListDir(DirectoryOrFile D, int Depth)
{
    if(D is a legitimate entry)  //合法的文件或目录
    {
        PrintName(D, Depth);
        if(D is a directory)
            for each child, C, of D
                ListDir(C, Depth + 1);
    }
}

void ListDirectory(DirectoryOrFile D)
{
    ListDir(D, 0);
}
```
- 后续遍历——计算所有文件占用的磁盘区块的总数
```C
static void SizeDirectory(DirectoryOrFile D)
{
    int TotalSize = 0;  //D及其所有后代的总大小
    if(D is a legitimate entry)
    {
        TotalSize = FileSize(D);
        if(D is a directory)
            for each child, C, of D
                TotalSize += SizeDirectory(C);
    }
    return TotalSize;
}
```

### 4.2 二叉树
二叉树的**平均深度**要比N小的多，这个性质有时很重要。这个平均深度为O($\sqrt{N}$),而对于特殊类型的二叉树，即二叉查找树，其深度的平均值为O(log N)

#### 1.实现
```C
typedef struct TreeNode *PtrToNode;

struct TreeNode
{
    ElementType Element;
    PtrToNode left;
    PtrToNode right;
}
```

#### 2.表达式树
==未实现==
表达式树的树叶是操作数，而其他节点为操作符
表达式树的中序遍历即为中缀表达式，后续遍历即为后缀表达式

##### 构造一颗表达式树
将后缀表达式转变为表达式树的算法与计算后缀表达式的算法极为相似
依次读取每个字符，如果是操作数，则建立一个单节点树并将一个指向它的指针推入栈中，如果是操作符，则弹出栈顶两个指针并以操作符为根节点形成一颗新的树并推入栈中

#### 3.查找树ADT
二叉树的一个重要应用是**查找**
假设给树中的每个节点指定一个关键字值，且所有关键字都是互异的，使二叉树成为二叉查找树的性质是，对于树中的每个节点X，它的左子树的所有的关键字值都小于X的关键字值，而它的右子树的所有的关键字值都大于X的关键字值
由于树的递归定义，通常是递归地编写二叉查找树的操作例程。因为二叉查找树的平均深度为O(log N)，所以一般不用担心栈空间被用尽
`见代码实现`
==删除操作==
如果删除的次数不多，通常使用的策略是**懒惰删除**：当一个元素被删除时，它仍留在树中，只是做了个被删除的记号

#### 6.平均情形分析
O(log N)

### 4.4 AVL树
一颗AVL树是其每个节点的左子树和右子树的高度最多相差1的二叉查找树
`见代码实现`
对AVL树的删除多少要比插入复杂。如果删除操作相对较少，那么懒惰删除应该是最好的策略


### 4.5 伸展树
==未完成==


### 4.6 树的遍历
- **中序遍历**——按顺序打印二叉查找树
```C
void PrintTree(SearchTree T)
{
    if(T)
    {
        PrintTree(T->Left);
        PrintElement(T->Element);
        PrintTree(T->Right);
    }
}
```
- **后序遍历**——计算树的高度
```C
int Height(Tree T)
{
    if(!T)
        return -1;
    else
        return 1 + Max(Height(T->Left), Height(T->Right));
}
```
- **先序遍历**——标记每一个节点的深度（打印文件目录）

- **层序遍历**
层序遍历用的很少，与其他遍历不同的地方在于它不是递归实现的，而是运用**队列**

所有这些例程都是**先处理NULL的情形**，然后才是其余的工作


### 4.7 B树
==未完成==


# 第五章——散列




