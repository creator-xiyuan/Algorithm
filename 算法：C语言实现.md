# 第一章——引论
（1）递归的基本法则：有基准情形、可以朝着基准不断推进、假设所有的递归调用都能运行、在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性工作

# 第二章——算法分析
（1）算法是为求解一个问题所需要遵循的、被清楚地指定的简单指令的集合

# 第三章——表、栈和队列
（1）**模块化**有几个优点。首先，**调试小程序要容易得多**。第二，**多个人**同时对一个模块式程序编程要更容易。第三，一个写得好的模块化程序把某些依赖关系只局限在一个例程中，这样使得**修改起来会更容易**。全局变量和副作用是有害的观念也正是出于模块化是有益的想法。

### 3.2 表ADT
#### 1.表的简单数组实现
插入和删除的运行时间非常慢且表的大小必须已知，所以表一般不用简单数组来实现

#### 2.链表
**虚拟头节点**可以很有效的处理特殊情况

#### 3.程序设计细节

#### 4.常见的错误
- 指针未初始化就使用
- 没有检查指针P是否为NULL就使用P->Next
- 声明一个指向结构的指针并不创建该结构，不需要malloc

#### 5.双链表

#### 6.循环链表
有表头/无表头、单链表/双链表

#### 7.例子
##### 多项式ADT
`见代码实现`
==乘法部分未完成==

##### 基数排序
==未完成==

##### 多重表
==未完成==

#### 8.链表的游标实现
==未完成==


### 3.3 栈ADT
#### 2.栈的实现
由于栈是一个表，因此任何实现表的方法都能实现栈。
但是，如果使用好的编程原则，那么调用例程不必知道使用的是哪种方法

##### 栈的链表实现
链表实现的缺点在于**对malloc和free的调用的开销**是昂贵的
有的缺点可以通过第二个栈来避免，第二个栈初始时为空栈，当一个单元从第一个栈弹出时，它只是被放到了第二个栈中。此后，当第一个栈需要新的单元时，它首先去查找第二个栈

##### 栈的数组实现
这是一个**更流行**的解决方案，只是唯一潜在的危害是需要提**提前声明数组的大小**
在典型的应用程序中，**声明一个数组足够大而不至于浪费太多空间通常并没有什么困难**
如果做不到这一点，那么更好的做法是用链表来实现
最现代化的计算机将**栈操作**作为它的**指令系统的一部分**，使其能**更快的运行**，这个事实说明，**栈**可能是仅次于**数组**的**最基本**的数据结构
**一个影响栈的执行效率的问题是错误检查**。频繁的错误检查可能会增加代码的复杂性和执行的开销。特别是在大量的栈操作中，错误检查可能会成为**性能瓶颈**。因此，在设计和实现栈时，需要权衡错误检查的**必要性和开销**，根据具体的使用场景进行合理的优化。

#### 3.应用
##### 符号配对

##### 后缀表达式
`见代码实现`
1. 后缀表达式的计算
数字入栈，遇到符号弹出两个数字进行计算，将结果入栈
2. 中缀到后缀的转换


##### 函数调用

