# 第一章——引论
（1）递归的基本法则：有基准情形、可以朝着基准不断推进、假设所有的递归调用都能运行、在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性工作

# 第二章——算法分析
（1）算法是为求解一个问题所需要遵循的、被清楚地指定的简单指令的集合

# 第三章——表、栈和队列
（1）**模块化**有几个优点。首先，**调试小程序要容易得多**。第二，**多个人**同时对一个模块式程序编程要更容易。第三，一个写得好的模块化程序把某些依赖关系只局限在一个例程中，这样使得**修改起来会更容易**。全局变量和副作用是有害的观念也正是出于模块化是有益的想法。

### 3.2 表ADT
#### 1.表的简单数组实现
插入和删除的运行时间非常慢且表的大小必须已知，所以表一般不用简单数组来实现

#### 2.链表
**虚拟头节点**可以很有效的处理特殊情况

#### 3.程序设计细节
`见代码实现`

#### 4.常见的错误
- 指针未初始化就使用
- 没有检查指针P是否为NULL就使用P->Next
- 声明一个指向结构的指针并不创建该结构，不需要malloc

#### 5.双链表

#### 6.循环链表
有表头/无表头、单链表/双链表

#### 7.例子
##### 多项式ADT
`见代码实现`
==乘法部分未完成==

##### 基数排序
==未完成==

##### 多重表
==未完成==

#### 8.链表的游标实现
==未完成==


### 3.3 栈ADT
#### 2.栈的实现
由于栈是一个表，因此任何实现表的方法都能实现栈。
但是，如果使用好的编程原则，那么调用例程不必知道使用的是哪种方法

##### 栈的链表实现
`见代码实现`
链表实现的缺点在于**对malloc和free的调用的开销**是昂贵的
有的缺点可以通过第二个栈来避免，第二个栈初始时为空栈，当一个单元从第一个栈弹出时，它只是被放到了第二个栈中。此后，当第一个栈需要新的单元时，它首先去查找第二个栈

##### 栈的数组实现
`见代码实现`
这是一个**更流行**的解决方案，只是唯一潜在的危害是需要提**提前声明数组的大小**
在典型的应用程序中，**声明一个数组足够大而不至于浪费太多空间通常并没有什么困难**
如果做不到这一点，那么更好的做法是用链表来实现
最现代化的计算机将**栈操作**作为它的**指令系统的一部分**，使其能**更快的运行**，这个事实说明，**栈**可能是仅次于**数组**的**最基本**的数据结构
**一个影响栈的执行效率的问题是错误检查**。频繁的错误检查可能会增加代码的复杂性和执行的开销。特别是在大量的栈操作中，错误检查可能会成为**性能瓶颈**。因此，在设计和实现栈时，需要权衡错误检查的**必要性和开销**，根据具体的使用场景进行合理的优化。

#### 3.应用
##### 符号配对

##### 后缀表达式
`见代码实现`
1. 后缀表达式的计算
数字入栈，遇到符号弹出两个数字进行计算，将结果入栈
2. 中缀到后缀的转换


##### 函数调用
```C
void PrintList(List L)
{
    if(L)
    {
        PrintElement(L->Element);
        //尾递归
        PrintList(L->Next);
    }
}
```
**尾递归**（在最后一行的递归调用）是使用递归**极端不当**的例子，应当使用更加自然的while循环结构
递归总能被彻底除去（编译器是在转变成汇编语言时完成的），但这么做是相当冗长乏味的。
虽然非递归程序一般比等价的递归程序要快，但是清晰性不足

### 3.4 队列

#### 2.数组实现
`见代码实现`

#### 3.队列的应用
队列是一种**先进先出**的结构，在生活中随处可见



# 第四章——树
对于**大量的**输入数据，链表的**线性访问时间太慢**，不宜使用。
**树**的大部分操作的运行时间平均为**O(log N)**
### 4.1 预备知识
- 树的递归定义：一颗树是一些结点的集合。这个集合可以是空集；若非空，则一棵树由根节点r以及0个或N个非空子树组成，每一颗子树的根都被来自根r的一条有向的边(edge)所连接
- 一棵树中从根到每个节点恰好存在一条路径

#### 1.树的实现
由于每个节点的**儿子数可以变化很大且事先不可知**，因此在数据结构中建立到各儿子节点的**直接链接是不可行的**，因为这样会**浪费太多空间**
实际上解法很简单：将每个节点的所有儿子都放在树节点的链表中
```C
typedef struct TreeNode *ProToNode;

struct TreeNode
{
    ElementType Element;
    ProToNode FirstChild;
    ProToNode NextSibling;
}
```

#### 2.树的遍历及应用
树有很多应用。流行的用法之一是Unix等**操作系统中的目录结构**（严格来说是类树）
- 先序遍历——列出目录中的所有文件
```C
static void ListDir(DirectoryOrFile D, int Depth)
{
    if(D is a legitimate entry)  //合法的文件或目录
    {
        PrintName(D, Depth);
        if(D is a directory)
            for each child, C, of D
                ListDir(C, Depth + 1);
    }
}

void ListDirectory(DirectoryOrFile D)
{
    ListDir(D, 0);
}
```
- 后续遍历——计算所有文件占用的磁盘区块的总数
```C
static void SizeDirectory(DirectoryOrFile D)
{
    int TotalSize = 0;  //D及其所有后代的总大小
    if(D is a legitimate entry)
    {
        TotalSize = FileSize(D);
        if(D is a directory)
            for each child, C, of D
                TotalSize += SizeDirectory(C);
    }
    return TotalSize;
}
```

### 4.2 二叉树
二叉树的**平均深度**要比N小的多，这个性质有时很重要。这个平均深度为O($\sqrt{N}$),而对于特殊类型的二叉树，即二叉查找树，其深度的平均值为O(log N)

#### 1.实现
```C
typedef struct TreeNode *PtrToNode;

struct TreeNode
{
    ElementType Element;
    PtrToNode left;
    PtrToNode right;
}
```

#### 2.表达式树
==未实现==
表达式树的树叶是操作数，而其他节点为操作符
表达式树的中序遍历即为中缀表达式，后续遍历即为后缀表达式

##### 构造一颗表达式树
将后缀表达式转变为表达式树的算法与计算后缀表达式的算法极为相似
依次读取每个字符，如果是操作数，则建立一个单节点树并将一个指向它的指针推入栈中，如果是操作符，则弹出栈顶两个指针并以操作符为根节点形成一颗新的树并推入栈中

#### 3.查找树ADT
二叉树的一个重要应用是**查找**
假设给树中的每个节点指定一个关键字值，且所有关键字都是互异的，使二叉树成为二叉查找树的性质是，对于树中的每个节点X，它的左子树的所有的关键字值都小于X的关键字值，而它的右子树的所有的关键字值都大于X的关键字值
由于树的递归定义，通常是递归地编写二叉查找树的操作例程。因为二叉查找树的平均深度为O(log N)，所以一般不用担心栈空间被用尽
`见代码实现`
==删除操作==
如果删除的次数不多，通常使用的策略是**懒惰删除**：当一个元素被删除时，它仍留在树中，只是做了个被删除的记号

#### 6.平均情形分析
O(log N)

### 4.4 AVL树
一颗AVL树是其每个节点的左子树和右子树的高度最多相差1的二叉查找树
`见代码实现`
对AVL树的删除多少要比插入复杂。如果删除操作相对较少，那么懒惰删除应该是最好的策略


### 4.5 伸展树
==未完成==


### 4.6 树的遍历
- **中序遍历**——按顺序打印二叉查找树
```C
void PrintTree(SearchTree T)
{
    if(T)
    {
        PrintTree(T->Left);
        PrintElement(T->Element);
        PrintTree(T->Right);
    }
}
```
- **后序遍历**——计算树的高度
```C
int Height(Tree T)
{
    if(!T)
        return -1;
    else
        return 1 + Max(Height(T->Left), Height(T->Right));
}
```
- **先序遍历**——标记每一个节点的深度（打印文件目录）

- **层序遍历**
层序遍历用的很少，与其他遍历不同的地方在于它不是递归实现的，而是运用**队列**

所有这些例程都是**先处理NULL的情形**，然后才是其余的工作


### 4.7 B树
==未完成==


# 第五章——散列
查找树ADT允许对一组元素进行各种操作。本章讨论**散列表ADT**只支持二叉查找树所允许的一部分操作
散列是一种以常数平均时间执行插入、删除和查找的技术，但是那些需要元素间任何排序信息的操作将不会得到有效的支持

### 5.2 散列函数
如果输入的关键字是整数，则一般合理的方法就是直接返回`Key mod TableSize`的结果
好的办法是保证表的大小是**素数**，这样散列函数不仅算起来简单，而且关键字的分配也很均匀（若表的大小是10而关键字都是以0为个位，则是个不好的选择）
**通常，关键字是字符串**，在这种情形下，**散列函数需要仔细地选择**

<strong>1. 将字符串中字符的ASCII码值加起来</strong>
```C
typedef unsigned int Index;

Index Hash(const char *Key, int TableSize)
{
    unsigned int HashVal = 0;
    while(*Key)
        HashVal += *Key++;
    return HashVal % TableSize;
}
```
**如果表很大，该函数则不会很好的分配关键字**（假设TableSize=10007，并设所有的关键字至多8个字符长，则HashVal的值至多为127*8=1016，这显然不是一种均匀的分配）

<strong>2. 考察前三个字符</strong>
```C
//假设Key至少由2个字符外加NULL结束
//值27表示英文字母个数外加一个空格
Index Hash(const char *Key, int TableSize)
{
    return (Key[0] + 27 * Key[1] + 729 * Key[2]) % TableSize;
}
```
虽然三个字符有$26^3=17576$种可能的组合，但查阅字典发现实际组合只有2851种
所以当散列表足够大时这个函数还是不合适

<strong>2. 考察所有字符</strong>
该函数计算$\sum_{i=0}^{KeySize - 1}{Key[KeySize - i - 1] * 32^i}$
```C
Index Hash(const char *Key, int TableSize)
{
    unsigned int HashVal = 0;
    //选择32是由于进行位运算速度更快
    while(*Key)
        HashVal = (Hashval << 5) + *Key++;
    return HashVal % TableSize;
}
```
如果关键词特别长，那么散列函数的计算将会花费过多时间
在这种情况下，通常的做法是不使用所有的字符，而是根据关键字的长度和性质做出选择

### 5.3 分离链接法
`见代码实现`
如果在散列的诸例程中不包括删除操作，那么最好不要使用表头（不能简化问题且会浪费大量空间）
除链表外，任何方案都有可能用来解决冲突现象——一颗二叉查找树甚至另外一个散列表，但是如果表足够大且散列函数足够好，那么就没有必要进行任何复杂的尝试


### 5.4 开放寻址法
在开放寻址法中，如果有冲突发生，那么就要选择其他的单元
选择依据为$h_{1}(X) = (Hash(X) + F(i))$ mod TableSize
下面来考察三个常用的冲突解决方法

#### 1.线性探测法
$F(i) = i$
缺点：存在**一次聚集现象**，插入效率较低
如果超过一半的表将被填满（λ > 0.5），那么线性探测就不是一个好方法

#### 2.平方探测法
$F(i) = i^{2}$
对于平方探测，我们保证如果表有一半是空的，且表的大小是素数，那么一定能够插入一个新的元素
如果表的大小是形如4k+3的素数且F(i) = $\pm i^2$，那么整个表均可被探测到，其代价是例程要略微复杂
`见代码实现`
虽然平方探测排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元，这叫作**二次聚集**

#### 3.双散列
$F(i) = i * hash_{2}(X)$
第二个散列函数的选择至关重要，一个良好的例子是$hash_{2}(X) = R - (X$ $mod$ $R)$，其中$R$为小于$TableSize$的素数
模拟表明，双散列预期的探测次数几乎和随机冲突解决方法相同，这使得双散列非常具有吸引力，不过，平方探测不需要使用第二个散列函数，从而在实践中可能更简单且更快


在开放寻址法中，**标准的删除操作不能进行**，因为相应的单元可能已经引起过冲突，元素绕过它去了别处
因此，开放寻址散列表需要**懒惰删除**

### 5.5 再散列
==未实现==

### 5.6 可扩散列
==未实现==


# 第六章——优先队列（堆）

